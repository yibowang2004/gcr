---
title: "Bernoulli"
author: "Yibo Wang"
output: html_document
---

```{r}
a1_fun <- function(x) {
  return(exp(x) / (1 + exp(x)))
}

a2_fun <- function(x) {
  return(exp(x) / (1 + exp(x)) ^ 2)
}

a4_fun <- function(x) {
  mu <- a1_fun(x)
  return(mu * (1 - mu) * ((1 - 2 * mu) ^ 2 - 2 * mu * (1 - mu)))
}

h_fun <- function(x) {
  return(x)
}

vecl <- function(X) {
  return(X[lower.tri(X, diag = FALSE)])
}

lower_to_full <- function(x) {
  n <- (1 + sqrt(1 + 8 * length(x))) / 2
  G <- matrix(0, n, n)
  lower <- lower.tri(G, diag = FALSE)
  G[lower] <- x
  G <- t(G)
  G[lower] <- x
  G <- t(G)
  return(G)
}

GZT <- function(X) {
  return(vecl(log_mat(X)))
}

recover_GZT <- function(x, tol = 1e-14, max_iter = 100) {
  G <- lower_to_full(x)
  n <- dim(G)[1]
  
  x_0 <- numeric(n)
  diag(G) <- x_0
  x_1 <- x_0 - log(diag(exp_mat(G)))
  
  step <- 0
  while(sum(abs(x_1 - x_0)) > tol && step < max_iter) {
    x_0 <- x_1
    diag(G) <- x_0
    x_1 <- x_0 - log(diag(exp_mat(G)))
    step <- step + 1
  }
  
  diag(G) <- x_1
  return(G)
}
```

```{r}
library(Rcpp)
library(RcppEigen)
sourceCpp(code = '
  // [[Rcpp::depends(RcppEigen)]]
  #include <RcppEigen.h>
  using namespace Rcpp;
  using Eigen::MatrixXd;
  using Eigen::VectorXd;
  using Eigen::SelfAdjointEigenSolver;
  
  // [[Rcpp::export]]
  Eigen::MatrixXd log_mat(const Eigen::MatrixXd& R) {
    Eigen::SelfAdjointEigenSolver<MatrixXd> solver(R);
    VectorXd eigvals = solver.eigenvalues();
    VectorXd log_eigvals = eigvals.array().log();
    return solver.eigenvectors() * log_eigvals.asDiagonal() * solver.eigenvectors().transpose();
  }
  
  // [[Rcpp::export]]
  Eigen::MatrixXd exp_mat(const Eigen::MatrixXd& R) {
    Eigen::SelfAdjointEigenSolver<MatrixXd> solver(R);
    VectorXd eigvals = solver.eigenvalues();
    VectorXd exp_eigvals = eigvals.array().exp();
    return solver.eigenvectors() * exp_eigvals.asDiagonal() * solver.eigenvectors().transpose();
  }
  
  // [[Rcpp::export]]
  Eigen::MatrixXd exp_solve_mat(const Eigen::MatrixXd& R) {
    Eigen::SelfAdjointEigenSolver<MatrixXd> solver(R);
    VectorXd eigvals = solver.eigenvalues();
    VectorXd exp_solve_eigvals = 1 / eigvals.array().exp();
    return solver.eigenvectors() * exp_solve_eigvals.asDiagonal() * solver.eigenvectors().transpose();
  }
  
  // [[Rcpp::export]]
  Eigen::MatrixXd exp_sqrt_solve_mat(const Eigen::MatrixXd& R) {
    Eigen::SelfAdjointEigenSolver<MatrixXd> solver(R);
    VectorXd eigvals = solver.eigenvalues();
    VectorXd exp_sqrt_solve_eigvals = 1 / eigvals.array().exp().sqrt();
    return solver.eigenvectors() * exp_sqrt_solve_eigvals.asDiagonal() * solver.eigenvectors().transpose();
  }
')
```

```{r}
generate_mv_binary <- function(p, delta, n_samples = 1) {
  if(dim(delta)[1] == 1) {
    return(rbinom(n_samples, 1, p))
  }
  
  J <- length(p)
  if (nrow(delta) != J || ncol(delta) != J) {
    stop("相关系数矩阵 delta 的维度必须与 p 的长度一致")
  }
  
  z <- qnorm(p)
  q <- 1 - p
  
  for (j in 1:(J-1)) {
    for (k in (j+1):J) {
      lower_bound <- max(
        -sqrt((p[j] * p[k]) / (q[j] * q[k])),
        -sqrt((q[j] * q[k]) / (p[j] * p[k]))
      )
      upper_bound <- min(
        sqrt((p[j] * q[k]) / (p[k] * q[j])),
        sqrt((p[k] * q[j]) / (p[j] * q[k]))
      )
      
      if (delta[j, k] < lower_bound || delta[j, k] > upper_bound) {
        return(NA)
      }
    }
  }

  Sigma <- diag(J) 
  
  for (j in 1:(J-1)) {
    for (k in (j+1):J) {
      target <- delta[j, k] * sqrt(p[j] * q[j] * p[k] * q[k]) + p[j] * p[k]
      
      low <- -0.9999
      high <- 0.9999
      tol <- 1e-6
      max_iter <- 100
      
      for (iter in 1:max_iter) {
        rho <- (low + high) / 2
        current_prob <- mvtnorm::pmvnorm(
          upper = c(z[j], z[k]),
          corr = matrix(c(1, rho, rho, 1), ncol = 2)
        )
        
        if (abs(current_prob - target) < tol) {
          Sigma[j, k] <- Sigma[k, j] <- rho
          break
        }
        
        if (current_prob < target) {
          low <- rho
        } else {
          high <- rho
        }
        
        if (iter == max_iter) {
          return(NA)
        }
      }
    }
  }
  
  eigenvalues <- eigen(Sigma, symmetric = TRUE, only.values = TRUE)$values
  if (any(eigenvalues < -tol)) {
      return(NA)
  }
  
  Z <- mvtnorm::rmvnorm(n_samples, mean = rep(0, J), sigma = Sigma)

  Y <- t(apply(Z, 1, function(row) as.integer(row <= z)))
  
  colnames(Y) <- paste0("Y", 1:J)
  
  return(Y)
}
```

```{r}
library(MASS)
library(mvtnorm)
library(gcr)

set.seed(123)

n <- 200
p <- 3
d <- 2
beta <- c(1, -0.5, 0.5)
alpha <- c(0.05, 0.15)
phi <- 1

error <- numeric(d + p + 1)
coverage <- numeric(d + p)
times <- 1000

alpha_rec <- matrix(0, nrow = times, ncol = d)
alpha_CI_rec <- matrix(0, nrow = times, ncol = d)
beta_rec <- matrix(0, nrow = times, ncol = p)
beta_CI_rec <- matrix(0, nrow = times, ncol = p)
phi_rec <- numeric(times)
phi_CI_rec <- numeric(times)

for(ii in 1:times) {
  m <- rbinom(n, 6, 0.8) + 1
  X <- list()
  Y <- list()
  mu <- list()
  W <- list()
  Gamma <- list()
  R <- list()
  A <- list()
  i <- 1
  while(TRUE) {
    X[[i]] <- matrix(0, m[i], p)
    W[[i]] <- matrix(0, 0, d)
    Gamma[[i]] <- matrix(0, m[i], m[i])
    
    #generate X and mu
    mean <- c(0, 0)
    sigma <- matrix(c(1, 0.5, 0.5, 1), 2, 2)
    for(j in 1:m[i]) {
      X[[i]][j, ] <- c(1, mvrnorm(1, mean, sigma))
    }
    mu[[i]] <- a1_fun(h_fun((X[[i]] %*% beta)))
    
    # generate W and sigma
    if(m[i] > 1) {
      u <- rbinom(m[i], 1, 0.5)
      for(k in 1:(m[i] - 1)) {
        for(j in (k + 1):m[i]) {
          W[[i]] <- rbind(W[[i]], c(1, ifelse(u[j] == u[k], 1, 0)))
        }
      }
    }
    R[[i]] <- exp_mat(recover_GZT(W[[i]] %*% alpha))
    
    # generate data y
    temp <- generate_mv_binary(mu[[i]], R[[i]], 1)
    if(typeof(temp) != "integer" && is.na(temp)) next
    Y[[i]] <- as.vector(generate_mv_binary(mu[[i]], R[[i]], 1))
    if(is.null(Y[[i]])) next
    
    i <- i + 1
    if(i > n) break
  }

  par_est <- gcr(Y, X, W, alpha, beta, 1, family = "Binomial")
  
  alpha_rec[ii, ] <- alpha_est <- par_est$alpha
  beta_rec[ii, ] <- beta_est <- par_est$beta
  phi_rec[ii] <- phi_est <- par_est$phi
  
  error <- error + abs(c(alpha_est - alpha, beta_est - beta, phi_est - phi))

  cov_alpha <- par_est$cov_alpha
  alpha_CI_rec[ii, ] <- CI_alpha <- qnorm(0.975) * sqrt(diag(cov_alpha))
  coverage[1:d] <- coverage[1:d] + as.numeric(abs(alpha_est - alpha) <= CI_alpha)
  
  cov_beta <- par_est$cov_beta
  beta_CI_rec[ii, ] <- CI_beta <- qnorm(0.975) * sqrt(diag(cov_beta))
  coverage[(d + 1):(d + p)] <- coverage[(d + 1):(d + p)] + as.numeric(abs(beta_est - beta) <= CI_beta)
}
```

