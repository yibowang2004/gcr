---
title: "Gaussian"
author: "Yibo Wang"
output: html_document
---

```{r}
a1_fun <- function(x) {
  return(x)
}

a2_fun <- function(x) {
  return(rep(1, length(x)))
}

h_fun <- function(x) {
  return(x)
}

vecl <- function(X) {
  return(X[lower.tri(X, diag = FALSE)])
}

lower_to_full <- function(x) {
  n <- (1 + sqrt(1 + 8 * length(x))) / 2
  G <- matrix(0, n, n)
  lower <- lower.tri(G, diag = FALSE)
  G[lower] <- x
  G <- t(G)
  G[lower] <- x
  G <- t(G)
  return(G)
}

GZT <- function(X) {
  return(vecl(log_mat(X)))
}

recover_GZT <- function(x, tol = 1e-14, max_iter = 100) {
  G <- lower_to_full(x)
  n <- dim(G)[1]
  
  x_0 <- numeric(n)
  diag(G) <- x_0
  x_1 <- x_0 - log(diag(exp_mat(G)))
  
  step <- 0
  while(sum(abs(x_1 - x_0)) > tol && step < max_iter) {
    x_0 <- x_1
    diag(G) <- x_0
    x_1 <- x_0 - log(diag(exp_mat(G)))
    step <- step + 1
  }
  
  diag(G) <- x_1
  return(G)
}
```

```{r}
library(Rcpp)
library(RcppEigen)
sourceCpp(code = '
  // [[Rcpp::depends(RcppEigen)]]
  #include <RcppEigen.h>
  using namespace Rcpp;
  using Eigen::MatrixXd;
  using Eigen::VectorXd;
  using Eigen::SelfAdjointEigenSolver;
  
  // [[Rcpp::export]]
  Eigen::MatrixXd log_mat(const Eigen::MatrixXd& R) {
    Eigen::SelfAdjointEigenSolver<MatrixXd> solver(R);
    VectorXd eigvals = solver.eigenvalues();
    VectorXd log_eigvals = eigvals.array().log();
    return solver.eigenvectors() * log_eigvals.asDiagonal() * solver.eigenvectors().transpose();
  }
  
  // [[Rcpp::export]]
  Eigen::MatrixXd exp_mat(const Eigen::MatrixXd& R) {
    Eigen::SelfAdjointEigenSolver<MatrixXd> solver(R);
    VectorXd eigvals = solver.eigenvalues();
    VectorXd exp_eigvals = eigvals.array().exp();
    return solver.eigenvectors() * exp_eigvals.asDiagonal() * solver.eigenvectors().transpose();
  }
  
  // [[Rcpp::export]]
  Eigen::MatrixXd exp_solve_mat(const Eigen::MatrixXd& R) {
    Eigen::SelfAdjointEigenSolver<MatrixXd> solver(R);
    VectorXd eigvals = solver.eigenvalues();
    VectorXd exp_solve_eigvals = 1 / eigvals.array().exp();
    return solver.eigenvectors() * exp_solve_eigvals.asDiagonal() * solver.eigenvectors().transpose();
  }
  
  // [[Rcpp::export]]
  Eigen::MatrixXd exp_sqrt_solve_mat(const Eigen::MatrixXd& R) {
    Eigen::SelfAdjointEigenSolver<MatrixXd> solver(R);
    VectorXd eigvals = solver.eigenvalues();
    VectorXd exp_sqrt_solve_eigvals = 1 / eigvals.array().exp().sqrt();
    return solver.eigenvectors() * exp_sqrt_solve_eigvals.asDiagonal() * solver.eigenvectors().transpose();
  }
')
```

```{r}
library(MASS)
library(mvtnorm)
library(gcr)

set.seed(123)

n <- 200
p <- 3
d <- 3
beta <- c(1, -0.5, 0.5)
alpha <- c(0.2, -0.2, 0.3)
phi <- 1

error <- numeric(d + p + 1)
coverage <- numeric(d + p + 1)
times <- 1000

alpha_rec <- matrix(0, nrow = times, ncol = d)
alpha_CI_rec <- matrix(0, nrow = times, ncol = d)
beta_rec <- matrix(0, nrow = times, ncol = p)
beta_CI_rec <- matrix(0, nrow = times, ncol = p)
phi_rec <- numeric(times)
phi_CI_rec <- numeric(times)

for(ii in 1:times) {
  m <- rbinom(n, 6, 0.8) + 1
  X <- list()
  Y <- list()
  mu <- list()
  W <- list()
  Gamma <- list()
  R <- list()
  A <- list()
  for(i in 1:n) {
    X[[i]] <- matrix(0, m[i], p)
    W[[i]] <- matrix(0, 0, d)
    Gamma[[i]] <- matrix(0, m[i], m[i])
    
    #generate X and mu
    mean <- c(0, 0)
    sigma <- matrix(c(1, 0.5, 0.5, 1), 2, 2)
    for(j in 1:m[i]) {
      X[[i]][j, ] <- c(1, mvrnorm(1, mean, sigma))
    }
    mu[[i]] <- Y[[i]] <- a1_fun(h_fun((X[[i]] %*% beta)))
    
    # generate W and sigma
    if(m[i] > 1) {
      u <- runif(m[i], 0, 1)
      for(k in 1:(m[i] - 1)) {
        for(j in (k + 1):m[i]) {
          W[[i]] <- rbind(W[[i]], c(1, u[j] - u[k], (u[j] - u[k]) ^ 2))
        }
      }
    }
    R[[i]] <- exp_mat(recover_GZT(W[[i]] %*% alpha))
    A[[i]] <- phi * diag(m[i])
    
    # generate data y
    e <- mvrnorm(1, rep(0, m[i]), sqrt(A[[i]]) %*% R[[i]] %*% sqrt(A[[i]]))
    Y[[i]] <- Y[[i]] + e
  }
  
  par_est <- gcr(Y, X, W, alpha, beta, phi, family = "Gaussian")
  
  alpha_rec[ii, ] <- alpha_est <- par_est$alpha
  beta_rec[ii, ] <- beta_est <- par_est$beta
  phi_rec[ii] <- phi_est <- par_est$phi
  
  error <- error + abs(c(alpha_est - alpha, beta_est - beta, phi_est - phi))

  cov_alpha <- par_est$cov_alpha
  alpha_CI_rec[ii, ] <- CI_alpha <- qnorm(0.975) * sqrt(diag(cov_alpha))
  coverage[1:d] <- coverage[1:d] + as.numeric(abs(alpha_est - alpha) <= CI_alpha)
  
  cov_beta <- par_est$cov_beta
  beta_CI_rec[ii, ] <- CI_beta <- qnorm(0.975) * sqrt(diag(cov_beta))
  coverage[(d + 1):(d + p)] <- coverage[(d + 1):(d + p)] + as.numeric(abs(beta_est - beta) <= CI_beta)
  
  var_phi <- par_est$var_phi
  phi_CI_rec[ii] <- CI_phi <- qnorm(0.975) * sqrt(var_phi)
  coverage[(d + p + 1)] <- coverage[(d + p + 1)] + as.numeric(abs(phi_est - phi) <= CI_phi)
}
```
