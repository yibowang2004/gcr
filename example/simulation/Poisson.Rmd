---
title: "Poisson"
author: "Yibo Wang"
output: html_document
---

```{r}
a1_fun <- function(x) {
  return(exp(x))
}

a2_fun <- function(x) {
  return(exp(x))
}

a4_fun <- function(x) {
  return(exp(x))
}

h_fun <- function(x) {
  return(x)
}

vecl <- function(X) {
  return(X[lower.tri(X, diag = FALSE)])
}

lower_to_full <- function(x) {
  n <- (1 + sqrt(1 + 8 * length(x))) / 2
  G <- matrix(0, n, n)
  lower <- lower.tri(G, diag = FALSE)
  G[lower] <- x
  G <- t(G)
  G[lower] <- x
  G <- t(G)
  return(G)
}

GZT <- function(X) {
  return(vecl(log_mat(X)))
}

recover_GZT <- function(x, tol = 1e-14, max_iter = 100) {
  G <- lower_to_full(x)
  n <- dim(G)[1]
  
  x_0 <- numeric(n)
  diag(G) <- x_0
  x_1 <- x_0 - log(diag(exp_mat(G)))
  
  step <- 0
  while(sum(abs(x_1 - x_0)) > tol && step < max_iter) {
    x_0 <- x_1
    diag(G) <- x_0
    x_1 <- x_0 - log(diag(exp_mat(G)))
    step <- step + 1
  }
  
  diag(G) <- x_1
  return(G)
}
```

```{r}
library(Rcpp)
library(RcppEigen)
sourceCpp(code = '
  // [[Rcpp::depends(RcppEigen)]]
  #include <RcppEigen.h>
  using namespace Rcpp;
  using Eigen::MatrixXd;
  using Eigen::VectorXd;
  using Eigen::SelfAdjointEigenSolver;
  
  // [[Rcpp::export]]
  Eigen::MatrixXd log_mat(const Eigen::MatrixXd& R) {
    Eigen::SelfAdjointEigenSolver<MatrixXd> solver(R);
    VectorXd eigvals = solver.eigenvalues();
    VectorXd log_eigvals = eigvals.array().log();
    return solver.eigenvectors() * log_eigvals.asDiagonal() * solver.eigenvectors().transpose();
  }
  
  // [[Rcpp::export]]
  Eigen::MatrixXd exp_mat(const Eigen::MatrixXd& R) {
    Eigen::SelfAdjointEigenSolver<MatrixXd> solver(R);
    VectorXd eigvals = solver.eigenvalues();
    VectorXd exp_eigvals = eigvals.array().exp();
    return solver.eigenvectors() * exp_eigvals.asDiagonal() * solver.eigenvectors().transpose();
  }
  
  // [[Rcpp::export]]
  Eigen::MatrixXd exp_solve_mat(const Eigen::MatrixXd& R) {
    Eigen::SelfAdjointEigenSolver<MatrixXd> solver(R);
    VectorXd eigvals = solver.eigenvalues();
    VectorXd exp_solve_eigvals = 1 / eigvals.array().exp();
    return solver.eigenvectors() * exp_solve_eigvals.asDiagonal() * solver.eigenvectors().transpose();
  }
  
  // [[Rcpp::export]]
  Eigen::MatrixXd exp_sqrt_solve_mat(const Eigen::MatrixXd& R) {
    Eigen::SelfAdjointEigenSolver<MatrixXd> solver(R);
    VectorXd eigvals = solver.eigenvalues();
    VectorXd exp_sqrt_solve_eigvals = 1 / eigvals.array().exp().sqrt();
    return solver.eigenvectors() * exp_sqrt_solve_eigvals.asDiagonal() * solver.eigenvectors().transpose();
  }
')
```

```{r}
GenerateMultivariatePoisson<-function(p, samples, R, lambda){
  normal_mu=rep(0, p)
  normal = MASS::mvrnorm(samples, normal_mu, R)
  unif=pnorm(normal)
  pois=t(qpois(t(unif), lambda))
  return(pois)
}

CorrectInitialCorrel<-function(lambda1, lambda2, r){
  samples=500
  u = runif(samples, 0, 1)
  lambda=c(lambda1,lambda2)
  maxcor=cor(qpois(u, lambda1), qpois(u, lambda2))
  mincor=cor(qpois(u, lambda1), qpois(1-u, lambda2))
  a=-maxcor*mincor/(maxcor+mincor)
  b=log((maxcor+a)/a, exp(1))
  c=-a
  corrected=log((r+a)/a, exp(1))/b
  corrected=ifelse ((corrected>1 | corrected<(-1)),
  NA, corrected)
  return(corrected)
}

CorrectInitialCorr <- function(lambda, R) {
  dim <- dim(R)[1]
  R_corr <- matrix(0, dim, dim)
  for(i in 1:dim) {
    for(j in 1:dim) {
      if(j == i) next
      c <- CorrectInitialCorrel(lambda[i], lambda[j], R[i, j])
      if(is.na(c)) return(NULL)
      R_corr[i, j] <- c
    }
  }
  diag(R_corr) <- rep(1, dim)
  eigenvalues <- eigen(R_corr, symmetric = TRUE, only.values = TRUE)$values
  if(any(eigenvalues < 0)) return(NULL)
  return(R_corr)
}
```

```{r}
library(MASS)
library(mvtnorm)
library(gcr)

set.seed(123)

n <- 200
p <- 3
d <- 3
beta <- c(1, -0.5, 0.5)
alpha <- c(0.2, -0.2, 0.3)
phi <- 1

error <- numeric(d + p + 1)
coverage <- numeric(d + p)
times <- 1000

alpha_rec <- matrix(0, nrow = times, ncol = d)
alpha_CI_rec <- matrix(0, nrow = times, ncol = d)
beta_rec <- matrix(0, nrow = times, ncol = p)
beta_CI_rec <- matrix(0, nrow = times, ncol = p)
phi_rec <- numeric(times)
phi_CI_rec <- numeric(times)

for(ii in 1:times) {
  m <- rbinom(n, 6, 0.8) + 1
  X <- list()
  Y <- list()
  lambda <- list()
  W <- list()
  Gamma <- list()
  R <- list()
  A <- list()
  i <- 1
  while(T) {
    X[[i]] <- matrix(0, m[i], p)
    W[[i]] <- matrix(0, 0, d)
    Gamma[[i]] <- matrix(0, m[i], m[i])
    
    #generate X and mu
    mean <- c(0, 0)
    sigma <- matrix(c(1, 0.5, 0.5, 1), 2, 2)
    for(j in 1:m[i]) {
      X[[i]][j, ] <- c(1, mvrnorm(1, mean, sigma))
    }
    lambda[[i]] <- a1_fun(h_fun((X[[i]] %*% beta)))
    
    # generate W and sigma
    if(m[i] > 1) {
      u <- runif(m[i], 0, 1)
      for(k in 1:(m[i] - 1)) {
        for(j in (k + 1):m[i]) {
          W[[i]] <- rbind(W[[i]], c(1, u[j] - u[k], (u[j] - u[k]) ^ 2))
        }
      }
    }
    R_temp <- exp_mat(recover_GZT(W[[i]] %*% alpha))
    R_corr <- CorrectInitialCorr(lambda[[i]], R_temp)
    
    if(is.null(R_corr)) next
    
    R[[i]] <- R_corr
    
    # generate data y
    Y[[i]] <- GenerateMultivariatePoisson(m[i], 1, R[[i]], lambda[[i]])
    
    i <- i + 1
    if(i > n) break
  }
  
  par_est <- gcr(Y, X, W, alpha, beta, phi, family = "Poisson")
  
  alpha_rec[ii, ] <- alpha_est <- par_est$alpha
  beta_rec[ii, ] <- beta_est <- par_est$beta
  phi_rec[ii] <- phi_est <- par_est$phi
  
  error <- error + abs(c(alpha_est - alpha, beta_est - beta, phi_est - phi))
  
  cov_alpha <- par_est$cov_alpha
  alpha_CI_rec[ii, ] <- CI_alpha <- qnorm(0.975) * sqrt(diag(cov_alpha))
  coverage[1:d] <- coverage[1:d] + as.numeric(abs(alpha_est - alpha) <= CI_alpha)
  
  cov_beta <- par_est$cov_beta
  beta_CI_rec[ii, ] <- CI_beta <- qnorm(0.975) * sqrt(diag(cov_beta))
  coverage[(d + 1):(d + p)] <- coverage[(d + 1):(d + p)] + as.numeric(abs(beta_est - beta) <= CI_beta)
}

```
