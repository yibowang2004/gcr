---
title: "Poisson"
author: "Yibo Wang"
output: html_document
---
```{r}
a1_fun <- function(x) {
  return(exp(x))
}

a2_fun <- function(x) {
  return(exp(x))
}

a4_fun <- function(x) {
  return(exp(x))
}

h_fun <- function(x) {
  return(x)
}

log_mat <- function(X) {
  eigen_X <- eigen(X, symmetric = TRUE)
  return(eigen_X$vectors %*% diag(log(eigen_X$values), nrow = dim(X)[1]) %*% t(eigen_X$vectors))
}

exp_mat <- function(X) {
  eigen_X <- eigen(X, symmetric = TRUE)
  return(eigen_X$vectors %*% diag(exp(eigen_X$values), nrow = dim(X)[1]) %*% t(eigen_X$vectors))
}

exp_solve_mat <- function(X) {
  eigen_X <- eigen(X, symmetric = TRUE)
  return(eigen_X$vectors %*% diag(1 / exp(eigen_X$values), nrow = dim(X)[1]) %*% t(eigen_X$vectors))
}

exp_sqrt_solve_mat <- function(X) {
  eigen_X <- eigen(X, symmetric = TRUE)
  return(eigen_X$vectors %*% diag(1 / sqrt(exp(eigen_X$values)), nrow = dim(X)[1]) %*% t(eigen_X$vectors))
}

vecl <- function(X) {
  return(X[lower.tri(X, diag = FALSE)])
}

lower_to_full <- function(x) {
  n <- (1 + sqrt(1 + 8 * length(x))) / 2
  G <- matrix(0, n, n)
  lower <- lower.tri(G, diag = FALSE)
  G[lower] <- x
  G <- t(G)
  G[lower] <- x
  G <- t(G)
  return(G)
}

GZT <- function(X) {
  return(vecl(log_mat(X)))
}

recover_GZT <- function(x, tol = 1e-14, max_iter = 100) {
  G <- lower_to_full(x)
  n <- dim(G)[1]
  
  x_0 <- numeric(n)
  diag(G) <- x_0
  x_1 <- x_0 - log(diag(exp_mat(G)))
  
  step <- 0
  while(sum(abs(x_1 - x_0)) > tol && step < max_iter) {
    x_0 <- x_1
    diag(G) <- x_0
    x_1 <- x_0 - log(diag(exp_mat(G)))
    step <- step + 1
  }
  
  diag(G) <- x_1
  return(G)
}
```

```{r}
GenerateMultivariatePoisson<-function(p, samples, R, lambda){
  normal_mu=rep(0, p)
  normal = MASS::mvrnorm(samples, normal_mu, R)
  unif=pnorm(normal)
  pois=t(qpois(t(unif), lambda))
  return(pois)
}

CorrectInitialCorrel<-function(lambda1, lambda2, r){
  samples=500
  u = runif(samples, 0, 1)
  lambda=c(lambda1,lambda2)
  maxcor=cor(qpois(u, lambda1), qpois(u, lambda2))
  mincor=cor(qpois(u, lambda1), qpois(1-u, lambda2))
  a=-maxcor*mincor/(maxcor+mincor)
  b=log((maxcor+a)/a, exp(1))
  c=-a
  corrected=log((r+a)/a, exp(1))/b
  corrected=ifelse ((corrected>1 | corrected<(-1)),
  NA, corrected)
  return(corrected)
}

CorrectInitialCorr <- function(lambda, R) {
  dim <- dim(R)[1]
  R_corr <- matrix(0, dim, dim)
  for(i in 1:dim) {
    for(j in 1:dim) {
      if(j == i) next
      c <- CorrectInitialCorrel(lambda[i], lambda[j], R[i, j])
      if(is.na(c)) return(NULL)
      R_corr[i, j] <- c
    }
  }
  diag(R_corr) <- rep(1, dim)
  eigenvalues <- eigen(R_corr, symmetric = TRUE, only.values = TRUE)$values
  if(any(eigenvalues < 0)) return(NULL)
  return(R_corr)
}
```

```{r}
library(snowfall)
library(MASS)
library(mvtnorm)
library(gcr)

sfInit(parallel = TRUE, cpus = 10)

set.seed(123)

n <- 100
p <- 3
d <- 3
beta <- c(1, -0.5, 0.5)
alpha <- c(0.2, -0.2, 0.3)
phi <- 1

err_mu <- 0
err_cov <- 0
error <- numeric(d + p + 1)
converge <- numeric(d + p)
times <- 1000

alpha_rec <- matrix(0, nrow = times, ncol = d)
beta_rec <- matrix(0, nrow = times, ncol = p)
phi_rec <- numeric(times)
mu_rec <- numeric(times)
cov_rec <- numeric(times)

for(ii in 1:times) {
  m <- rbinom(n, 6, 0.8) + 1
  X <- list()
  Y <- list()
  lambda <- list()
  W <- list()
  Gamma <- list()
  R <- list()
  A <- list()
  i <- 1
  while(T) {
    X[[i]] <- matrix(0, m[i], p)
    W[[i]] <- matrix(0, 0, d)
    Gamma[[i]] <- matrix(0, m[i], m[i])
    
    #generate X and mu
    mean <- c(0, 0)
    sigma <- matrix(c(1, 0.5, 0.5, 1), 2, 2)
    for(j in 1:m[i]) {
      X[[i]][j, ] <- c(1, mvrnorm(1, mean, sigma))
    }
    lambda[[i]] <- a1_fun(h_fun((X[[i]] %*% beta)))
    
    # generate W and sigma
    if(m[i] > 1) {
      u <- runif(m[i], 0, 1)
      for(k in 1:(m[i] - 1)) {
        for(j in (k + 1):m[i]) {
          W[[i]] <- rbind(W[[i]], c(1, u[j] - u[k], (u[j] - u[k]) ^ 2))
        }
      }
    }
    R_temp <- exp_mat(recover_GZT(W[[i]] %*% alpha))
    R_corr <- CorrectInitialCorr(lambda[[i]], R_temp)
    
    if(is.null(R_corr)) next
    
    R[[i]] <- R_corr
    
    # generate data y
    Y[[i]] <- GenerateMultivariatePoisson(m[i], 1, R[[i]], lambda[[i]])
    
    i <- i + 1
    if(i > n) break
  }
  
  par_init <- c(alpha, beta, phi)
  par_est <- gcr(Y, X, W, alpha, beta, phi, family = "Poisson", method.mean = "naive", accelerate = T)
  
  alpha_rec[ii, ] <- alpha_est <- par_est$alpha
  beta_rec[ii, ] <- beta_est <- par_est$beta
  phi_rec[ii] <- phi_est <- par_est$phi
  
  error <- error + abs(c(alpha_est - alpha, beta_est - beta, phi_est - phi))
  
  H1_est <- par_est$H_1
  CI_beta <- qnorm(0.975) * sqrt(diag(solve(H1_est)))
  converge[(d + 1):(d + p)] <- converge[(d + 1):(d + p)] + as.numeric(abs(beta_est - beta) <= CI_beta)
  
  H2_est <- par_est$H_2
  Hessian_solve <- solve(par_est$Hessian)
  CI_alpha <- qnorm(0.975) * sqrt(diag(Hessian_solve %*% H2_est %*% Hessian_solve))
  converge[1:d] <- converge[1:d] + as.numeric(abs(alpha_est - alpha) <= CI_alpha)
}

sfStop()
```